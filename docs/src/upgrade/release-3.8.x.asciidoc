////
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
////

= TinkerPop 3.8.0

image::gremlin-running.png[width=185]

*NOT OFFICIALLY NAMED YET*

== TinkerPop 3.8.0

*Release Date: NOT OFFICIALLY RELEASED YET*

Please see the link:https://github.com/apache/tinkerpop/blob/3.8.0/CHANGELOG.asciidoc#release-3-8-0[changelog] for a
complete list of all the modifications that are part of this release.

=== Upgrading for Users

==== Number Conversion Step

The new `asNumber()` step provides type casting functionality to Gremlin. It serves as an umbrella step that parses
strings and casts numbers into desired types. For the convenience of remote traversals in GLVs, these available types
are denoted by a set of number tokens (`N`).

This new step will allow users to normalize their data by converting string numbers and mixed numeric types to a
consistent format, making it easier to perform downstream mathematical operations. As an example:

[source,text]
----
// sum() step can only take numbers
gremlin> g.inject(1.0, 2l, 3, "4", "0x5").sum()
class java.lang.String cannot be cast to class java.lang.Number

// use asNumber() to avoid casting exceptions
gremlin> g.inject(1.0, 2l, 3, "4", "0x5").asNumber().sum()
==>15.0

// given sum() step returned a double, one can use asNumber() to further cast the result into desired type
gremlin> g.inject(1.0, 2l, 3, "4", "0x5").asNumber().sum().asNumber(N.int_)
==>15
----

Semantically, the `asNumber()` step will convert the incoming traverser to a logical parsable type if no argument is
provided, or to the desired numerical type, based on the number token (`N`) provided.

Numerical input will pass through unless a type is specified by the number token. `ArithmeticException` will be thrown
for any overflow as a result of narrowing of types:

[source,text]
----
gremlin> g.inject(5.0).asNumber(N.int_)
==> 5    // casts double to int
gremlin> g.inject(12).asNumber(N.byte_)
==> 12
gremlin> g.inject(128).asNumber(N.byte_)
==> ArithmeticException
----

String input will be parsed. By default, the smalled unit of number to be parsed into is `int` if no number token is
provided. `NumberFormatException` will be thrown for any unparsable strings:

[source,text]
----
gremlin> g.inject("5").asNumber()
==> 5
gremlin> g.inject("5.7").asNumber(N.int_)
==> 5
gremlin> g.inject("1,000").asNumber(N.int_)
==> NumberFormatException
gremlin> g.inject("128").asNumber(N.byte_)
==> ArithmeticException
----

All other input types will result in `IllegalArgumentException`:
[source,text]
----
gremlin> g.inject([1, 2, 3, 4]).asNumber()
==> IllegalArgumentException
----

See: link:https://tinkerpop.apache.org/docs/3.8.0/reference/#asNumber-step[asNumber()-step]
See: link:https://issues.apache.org/jira/browse/TINKERPOP-3166[TINKERPOP-3166]

==== Boolean Conversion Step

The `asBool()` step bridges another gap in Gremlin's casting functionalities. Users now have the ability to parse
strings and numbers into boolean values, both for normalization and to perform boolean logic with numerical values.

[source,text]
----
gremlin> g.inject(2, "true", 1, 0, false, "FALSE").asBool().fold()
==>[true,true,true,false,false,false]

// using the modern graph, we can turn count() results into boolean values
gremlin> g.V().local(outE().count()).fold()
==>[3,0,0,2,0,1]
gremlin> g.V().local(outE().count()).asBool().fold()
==>[true,false,false,true,false,true]
// a slightly more complex one using sack for boolean operations for vertices with both 'person' label and has out edges
gremlin> g.V().sack(assign).by(__.hasLabel('person').count().asBool()).sack(and).by(__.outE().count().asBool()).sack().path()
==>[v[1],true]
==>[v[2],false]
==>[v[3],false]
==>[v[4],true]
==>[v[5],false]
==>[v[6],true]
----

See: link:https://tinkerpop.apache.org/docs/3.8.0/reference/#asBool-step[asBool()-step]
See: link:https://issues.apache.org/jira/browse/TINKERPOP-3175[TINKERPOP-3175]

==== none() and discard()

There is a complicated relationship with the `none()` and `discard()` steps that begs some discussion. Prior to this
version, the `none()` step was used to "throw away" all traversers that passed into it. In 3.8.0, that step has been
renamed to `discard()`. The `discard()` step with its verb tone arguably makes for a better name for that feature, but
it also helped make room for `none()` to be repurposed as `none(P)` which is a complement to `any(P)` and `all(P) steps.

==== Simplified Comparability Semantics

The previous system of ternary boolean semantics has been replaced with simplified binary semantics. The triggers for
"ERROR" states from illegal comparisons are unchanged (typically comparisons with NaN or between incomparable types
such as String and int). The difference now is that instead of the ERROR being propagated according to ternary logic
semantics until a reduction point is reached, the error now immediately returns a value of FALSE.

This will be most visible in expressions which include negations. Prior to this change, `g.inject(NaN).not(is(1))` would
produce no results as `!(NaN == 1)` -> `!(ERROR)` -> `ERROR` -> traverser is filtered out. After this change, the same
traversal will return NaN as the same expression now evaluates as `!(NaN == 1)` -> `!(FALSE)` -> `TRUE` -> traverser is
not filtered.

See: link:https://tinkerpop.apache.org/docs/3.8.0/dev/provider/#gremlin-semantics-equality-comparability[Comparability semantics docs]

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3173[TINKERPOP-3173]

==== Set minimum Java version to 11

TinkerPop 3.8 requires a minimum of Java 11 for building and running. Support for Java 1.8 has been dropped.

==== Auto-promotion of Numbers

Previously, operations like `sum` or `sack` that involved mathematical calculations did not automatically promote the
result to a larger numeric type (e.g., from int to long) when needed. As a result, values could wrap around within their
current type leading to unexpected behavior. This issue has now been resolved by enabling automatic type promotion for
results.

Now, any mathematical operations such as `Add`, `Sub`, `Mul`, and `Div` will now automatically promote to the next
numeric type if an overflow is detected. For integers, the promotion sequence is: byte → short → int → long → overflow
exception. For floating-point numbers, the sequence is: float → double → infinity.

The following example showcases the change in overflow behavior between 3.7.3 and 3.8.0

[source,text]
----
// 3.7.3
gremlin> g.inject([Byte.MAX_VALUE, (byte) 1], [Short.MAX_VALUE, (short) 1], [Integer.MAX_VALUE,1], [Long.MAX_VALUE, 1l]).sum(local)
==>-128 // byte
==>-32768 // short
==>-2147483648 // int
==>-9223372036854775808 // long

gremlin> g.inject([Float.MAX_VALUE, Float.MAX_VALUE], [Double.MAX_VALUE, Double.MAX_VALUE]).sum(local)
==>Infinity // float
==>Infinity // double

// 3.8.0
gremlin> g.inject([Byte.MAX_VALUE, (byte) 1], [Short.MAX_VALUE, (short) 1], [Integer.MAX_VALUE,1]).sum(local)
==>128 // short
==>32768 // int
==>2147483648 // long

gremlin> g.inject([Long.MAX_VALUE, 1l]).sum(local)
// throws java.lang.ArithmeticException: long overflow

gremlin> g.inject([Float.MAX_VALUE, Float.MAX_VALUE], [Double.MAX_VALUE, Double.MAX_VALUE]).sum(local)
==>6.805646932770577E38 // double
==>Infinity // double
----

See link:https://issues.apache.org/jira/browse/TINKERPOP-3115[TINKERPOP-3115]

==== Prefer OffsetDateTime

The default implementation for date type in Gremlin is now changed from the `java.util.Date` to the more encompassing
`java.time.OffsetDateTime`. This means the reference implementation for all date manipulation steps, `asDate()`,
`dateAdd()`, and `dateDiff()`, as well as helper methods `datetime()`, will return `OffsetDateTime`, whose string
representation will be in ISO 8601 format.

`Date` is still supported as incoming traverser results for these steps, as well as input into `dateDiff()` for
compatibility purposes. All dates are assumed to be in `UTC` (given epoch time).

If one is using a persisted TinkerGraph that stored `Date` objects inside properties, one may notice `OffsetDateTime`
being returned after traversal manipulation. The recommended solution is to update all existing `Date` objects into
`OffsetDateTime`. This can be done by querying for the properties and transforming them using `asDate()`. Note that all
dates are assumed to be in `UTC` (given epoch time).

For Python, Go, JavaScript, and .NET GLVs, the existing date types are retained. The change is at the serialization
level, where the exiting date type will be serialized as `OffsetDateTime` to the server, and both `Date` and
`OffsetDateTime` from the server will be deserialized into the existing date types in the host language. As such, users
of these GLVs should not notice impact to the application code. The caution remains in cases when client is accessing a
database with `Date` object stored, the `Date` to `OffsetDateTime` transformations on the server assumes `UTC` timezone.

For Java GLV, this change would impact users who are expecting the old `Date` object from a traversal in their
application, in this case the recommendation is to update code to expect `OffsetDateTime` as part of the version
upgrade.

==== Simplify g Construction

The creation of "g" is the start point to writing Gremlin. There are a number of ways to create it, but TinkerPop has
long recommended the use of the anonymous `traversal()` function for this creation.

[source,groovy]
----
// for embedded cases
graph = TinkerGraph.open()
g = traversal().withEmbedded(graph)
// for remote cases
g = traversal().withRemote(DriverRemoteConnection.using(...)))
----

As of this release, those two methods have been deprecated in favor of just `with()` which means you could simply write:

[source,groovy]
----
// for embedded cases
graph = TinkerGraph.open()
g = traversal().with(graph)
// for remote cases
g = traversal().with(DriverRemoteConnection.using(...)))
----

That's a bit less to type, but also removes the need to programmatically decide which function to call, which hopefully
strengthens the abstraction further. To demonstrate this further, consider this next example:

[source,groovy]
----
g = traversal().with("config.properties")
----

The properties file in the above example can either point to a remote configuration or a embedded configuration allowing
"g" to be switched as needed without code changes.

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3017[TINKERPOP-3017]

==== split() on Empty String

The `split()` step will now split a string into a list of its characters if the given separator is an empty string.

[source,text]
----
// 3.7.3
g.inject("Hello").split("")
==>[Hello]

// 3.8.0
g.inject("Hello").split("")
==>[H,e,l,l,o]
----

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3083[TINKERPOP-3083]

==== asString() No Longer Allow Nulls
The `asString()` step will no longer allow `null` input. An `IllegalArgumentException` will be thrown for consistency with all other parsing steps (i.e. `asDate()`, `asBool()`, `asNumber()`).

See: link:https://lists.apache.org/thread/q76pgrvhprosb4lty63bnsnbw2ljyl7m[DISCUSS] thread

==== Javascript Set Deserialization

Starting from this version, `gremlin-javascript` will deserialize `Set` data into a ECMAScript 2015 Set. Previously,
these were deserialized into arrays.

==== .NET Byte Serialization Change

The Gremlin .NET serializers has been updated to correctly handle byte values as signed integers to align with the IO
specification, whereas previously it incorrectly serialized and deserialized bytes as unsigned values.

This is a breaking change for .NET applications that rely on byte values. Existing applications using byte values should consider switching to `sbyte` for signed byte operations or `short` for a wider range of values to maintain compatibility.

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3161[TINKERPOP-3161]

==== Removal of P.getOriginalValue()

`P.getOriginalValue()` has been removed as it was not offering much value and was often confused with `P.getValue()`.
Usage of `P.getOriginalValue()` often leads to unexpected results if called on a predicate which has had its value reset
after construction. All usages of `P.getOriginalValue()` should be replaced with `P.getValue()`.

==== Gremlin Grammar Changes

A number of changes have been introduced to the Gremlin grammar to help make it be more consistent and easier to use.

*Removed Vertex References for Grammar*

The grammar allowed the construction of a `Vertex` by way of syntax like `new Vertex(1,'person')` (or with similar
arguments to `ReferenceVertex`). This syntax has been removed as it served little purpose within the grammar as it
merely adds more characters to wrap around the identifier, which could simply be used by itself.

The `V()` step, as well as the `from()` and `to()` modulators used with `addE()`, previously accepted `Vertex` as
arguments in the grammar. In its place, the `from()` and `to()` modulators can now directly accept a vertex id in place
of a `Vertex` when used with `addE()` (`V()` has always accepted ids in addition to vertices). When using these steps in
`gremlin-lang` scripts, the vertex id must be used directly.

This change has no effect on the `GraphTraversal` API, nor on `gremlin-groovy` scripts. Vertices can continue to be used
directly in those contexts.

[source,text]
----
// 3.7.3
gremlin> v1 = g.V(1).next()
==>v[1]
gremlin> v2 = g.V(2).next()
==>v[2]
gremlin> script = String.format("g.V(new Vertex(%s)).outE().where(inV().is(new Vertex(%s)))", v1.id(), v2.id())
==>g.V(new Vertex(1)).outE().where(inV().is(new Vertex(2)))
gremlin> client.submit(script).all().get().get(0).getEdge()
==>e[7][1-knows->2]

// 3.8.0
gremlin> v1 = g.V(1).next()
==>v[1]
gremlin> v2 = g.V(2).next()
==>v[2]
gremlin> script = String.format("g.V(%s).outE().where(inV().id().is(%s))", v1.id(), v2.id())
==>g.V(1).outE().where(inV().id().is(2))
gremlin> client.submit(script).all().get().get(0).getEdge()
==>e[7][1-knows->2]
----

*`new` keyword is now optional*

The `new` keyword is now optional in all cases where it was previously used. Both of the following examples are now
valid syntax with the second being the preferred form going forward:

[source,groovy]
----
g.V().withStrategies(new SubgraphStrategy(vertices: __.hasLabel('person')))

g.V().withStrategies(SubgraphStrategy(vertices: __.hasLabel('person')))
----

In a future version, it is likely that the `new` keyword will be removed entirely from the grammar.

*Supports withoutStrategies()*

The `withoutStrategies()` configuration step is now supported syntax for the grammar. While this option is not commonly
used it is still a part of the Gremlin language and there are times when it is helpful to have this fine-grained
control over how a traversal works.

[source,groovy]
----
g.V().withoutStrategies(CountStrategy)
----

*`Map` keys restrictions*

Earlier versions of the grammar allowed a wide range of values for the keys. In many cases, these didn't really make
sense for Gremlin and were just inherited from the Groovy language since Gremlin tends to follow that language in many
ways. That said, Gremlin did take some liberties with that syntax and introduced its own shorthand for some cases. Those
shorthands created unfortunate situations where certain words were being prevented as being able to be used as keys
which could lead to confusion.

A `Map` is still defined in the same way it always has been, where the following two lines produce an equivalent `Map`:

[source,groovy]
----
[label: 100]
["label": 100]
----

Note that when quotes are not used to denote a string, Gremlin will assume that the intention is to shorthand a string
key and not reference a Gremlin keyword. To reference an allowable keyword as the key, either wrap it with parenthesis
or use its longhand form as shown in the following examples which all produce the same `Map`:

[source,groovy]
----
[T.id: 100]
[(T.id): 100]
[(id): 100]
----

Note that the first example is a Gremlin convenience that is not compatible in Groovy. This does produce a syntax error
in Groovy's case. When upgrading to 3.8.0, it will be important to evaluate any code using scripts with `Map` keys that
match keywords that are not wrapped in parentheses. On upgrade they will begin to be treated as `String` keys rather
than their `Enum` value. This is particularly relevant for `property(Map)`, `mergeV` and `mergeE` which use a 'Map`
for their arguments and commonly require that `T` and `Direction` be used as keys.

The following examples show some `Map` usage from older versions that will work without a need for changes in 3.8.0:

[source,groovy]
----
// the long forms are used and each are wrapped in parenthesis
g.mergeE([(T.label):'Sibling',created:'2022-02-07',(Direction.from):1,(Direction.to):2])

// the short forms are used and each are wrapped in parenthesis
g.mergeE([(label):'Sibling',created:'2022-02-07',(Direction.from):1,(Direction.to):2])

// the long forms are used and for Gremlin this is a syntax convenience to spare typing
// the parenthesis
g.mergeE([T.label:'Sibling',created:'2022-02-07',Direction.from:1,Direction.to:2])

// while the following line mixes qualified enums with T and uses shorthand for Direction
// with from and to all of the enums are wrapped in parenthesis
g.mergeE([(T.label):'Sibling',created:'2022-02-07',(from):1,(to):2])
----

In this next example, the `Map` keys are defined in a way that changes will be necessary in 3.8.0:

[source,groovy]
----
// none of the keys below are qualified with their enum long form nor are they wrapped in
// parenthesis and as a result will be treated as String key values in 3.8.0 unless a
// change is made
g.mergeE([label:'Sibling',created:'2022-02-07',from:1,to:2])
----

*Restriction of Step Arguments*

Prior to 3.7.0, the grammar did not allow for any parameters in gremlin scripts. In 3.7, the grammar rules
were loosened to permit variable use almost anywhere in a traversal, in a similar fashion as groovy, however
immediately resolved upon parsing the script, and did not bring the same performance benefits as
parameterization in groovy scripts brings. Parameters in gremlin-lang scripts are restricted to a
link:++https://tinkerpop.apache.org/docs/x.y.z/dev/reference/#traversal-parameterization++[subset of steps]
in 3.8.0, and scripts which use variables elsewhere will result in parsing exceptions. The implementation
has been updated to persist query parameters through traversal construction and strategy application.
Parameter persistence opens the door certain optimizations for repeated query patterns. Consult your
providers documentation for specific recommendations on using query parameters with gremlin-lang scripts in
TinkerPop 3.8.

See: link:https://issues.apache.org/jira/browse/TINKERPOP-2862[TINKERPOP-2862],
link:https://issues.apache.org/jira/browse/TINKERPOP-3046[TINKERPOP-3046],
link:https://issues.apache.org/jira/browse/TINKERPOP-3047[TINKERPOP-3047],
link:https://issues.apache.org/jira/browse/TINKERPOP-3023[TINKERPOP-3023]

==== SeedStrategy Construction

The `SeedStrategy` public constructor has been removed for Java and has been replaced by the builder pattern common
to all strategies. This change was made to ensure that the `SeedStrategy` could be constructed consistently.

==== Improved Translators

The various Java `Translator` implementations allowing conversion of Gremlin traversals to string forms in various
languages have been modified considerably. First, they have been moved from to the
`org.apache.tinkerpop.gremlin.language.translator` package, because they now depend on the ANTLR grammar in
`gremlin-language` to handled the translation process. Making this change allowed for a more accurate translation of
Gremlin that doesn't need to rely on reflection and positional arguments to determine which step was intended for use.

Another important change was the introduction of specific translators for Groovy and Java. While Groovy translation
tends to work for most Java cases, there is syntax specific to Groovy where it does not. With a specific Java
translator, the translation process can be more accurate and less error-prone.

The syntax for the translators has simplified as well. The translator function now takes a Gremlin string and a target
language to translate to. Consider the following example:

[source,text]
----
gremlin> GremlinTranslator.translate("g.V().out('knows')", Translator.GO)
==>g.V().Out("knows")
----

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3028[TINKERPOP-3028]

==== Deprecated UnifiedChannelizer

The `UnifiedChannelizer` was added in 3.5.0 in any attempt to streamline Gremlin Server code paths and resource usage.
It was offered as an experimental feature and as releases went on was not further developed, particularly because of the
major changes to Gremlin Server expected in 4.0.0 when websockets are removed. The removal of websockets with a pure
reliance on HTTP will help do what the `UnifiedChannelizer` tried to do with its changes. As a result, there is no need
to continue to refine this `Channelizer` implementation and it can be deprecated.

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3168[TINKERPOP-3168]

==== OptionsStrategy in Python

The `\\__init__()` syntax has been updated to be both more Pythonic and more aligned to the `gremlin-lang` syntax.
Previously, `OptionsStrategy()` took a single argument `options` which was a `dict` of all options to be set.
Now, all options should be set directly as keyword arguments.

For example:

[source,python]
----
# 3.7 and before:
g.with_strategies(OptionsStrategy(options={'key1': 'value1', 'key2': True}))
# 4.x and newer:
g.with_strategies(OptionsStrategy(key1='value1', key2=True))

myOptions = {'key1': 'value1', 'key2': True}
# 3.7 and before:
g.with_strategies(OptionsStrategy(options=myOptions))
# 4.x and newer:
g.with_strategies(OptionsStrategy(**myOptions))
----

==== choose() Semantics

Several enhancements and clarifications have been made to the `choose()` step in TinkerPop 3.8.0 to improve its behavior
and make it more consistent:

*First Matched Option Only*

The `choose()` step now only executes the first matching option traversal. In previous versions, if multiple options
could match, all matching options would be executed. This change provides more predictable behavior and better aligns
with common switch/case semantics in programming languages.

[source,text]
----
// In 3.7.x and earlier, if multiple options matched, all would be executed
gremlin> g.V().hasLabel("person").
......1>   choose(__.values("age")).
......2>     option(P.between(26, 30), __.constant("young")).
......3>     option(P.between(20, 30), __.constant("also young"))
==>young
==>also young
==>young
==>also young


// In 3.8.x, only the first matching option is executed
gremlin> g.V().hasLabel("person").
......1>   choose(__.values("age")).
......2>     option(P.between(26, 30), __.constant("young")).
......3>     option(P.between(20, 30), __.constant("never reached for ages 26-30"))
==>young
==>young
----

*Automatic Pass-through for Unproductive and Unmatched Predicates*

The `choose()` step now passes through traversers when the choice traversal is unproductive or the determined choice
unmatched. Before this version, unproductive traversals produced an error and unmatched choices were filtered by
default.

[source,text]
----
gremlin> g.V().choose(__.values("age")).
......1>         option(P.between(26, 30), __.values("name")).
......2>         option(Pick.none, __.values("name"))
==>marko
==>vadas
==>v[3]
==>josh
==>v[5]
==>peter
gremlin> g.V().choose(T.label).
......1>        option("person", __.out("knows").values("name")).
......2>        option("bleep", __.out("created").values("name"))
==>vadas
==>josh
==>v[3]
==>v[5]
----

This change makes the switch semantics for `choose()` consistent with those of the if-then-else semantics for
`choose()`.

*Pick.unproductive for Unproductive Predicates*

A new special option token `Pick.unproductive` has been added to handle cases where the choice traversal produces no
results. This is particularly useful for handling elements that don't have the properties being evaluated.

[source,text]
----
// In 3.7.x, vertices without an age property would pass through unchanged
gremlin> g.V().choose(__.values("age")).
......1>         option(P.between(26, 30), __.values("name")).
......2>         option(Pick.none, __.values("name"))
==>marko
==>vadas
The provided traverser does not map to a value: v[3][TinkerVertex]->[PropertiesStep([age],value)][DefaultGraphTraversal] parent[[TinkerGraphStep(vertex,[]), ChooseStep([PropertiesStep([age],value)],[[none, [[PropertiesStep([name],value), EndStep]]], [(and(gte(26), lt(30))), [PropertiesStep([name],value), EndStep]]])]]
Type ':help' or ':h' for help.
Display stack trace? [yN]

// In 3.8.x, you can specifically handle vertices where the choice traversal is unproductive
gremlin> g.V().choose(__.values("age")).
......1>         option(P.between(26, 30), __.values("name")).
......2>         option(Pick.none, __.values("name")).
......3>         option(Pick.unproductive, __.label())
==>marko
==>vadas
==>software
==>josh
==>software
==>peter
----

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3178[TINKERPOP-3178],
link:https://tinkerpop.apache.org/docs/3.8.0/reference/#choose-step[Reference Documentation - choose()]

==== Float Defaults to Double

The `GremlinLangScriptEngine` has been modified to treat float literals without explicit type suffixes (like 'm', 'f',
or 'd') as Double by default. Users who need `BigDecimal` precision can still use the 'm' suffix (e.g., 1.0m).
`GremlinGroovyScriptEngine` will still default to `BigDecimal` for `float` literals.

==== Consistent Output for range(), limit(), tail()

The `range(local)`, `limit(local)`, and `tail(local)` steps now consistently return collections rather than automatically 
unfolding single-element results when operating on iterable collections (List, Set, etc.). Previously, when these steps 
operated on collections and the result contained only one element, the step would return the single element directly 
instead of a collection containing that element.

This change ensures predictable return types based on the input type, making the behavior more consistent and intuitive.
Note that this change only affects iterable collections - Map objects continue to behave as before.

[WARNING]
====
This is a breaking change that may require modifications to existing queries. If your queries relied on the previous 
behavior of receiving single elements directly from `range(local)`, `limit(local)`, or `tail(local)` steps, you will 
need to add `.unfold()` after these steps to maintain the same functionality. Without this update, some existing queries 
may throw a `ClassCastException` while others may return unexpected results.
====

[source,text]
----
// 3.7.x and earlier - inconsistent output types for collections
gremlin> g.inject([1, 2, 3]).limit(local, 1)
==>1  // single element returned directly

gremlin> g.inject([1, 2, 3]).limit(local, 2) 
==>[1,2]  // collection returned

// 3.8.0 - consistent collection output for collections
gremlin> g.inject([1, 2, 3]).limit(local, 1)
==>[1]  // collection always returned

gremlin> g.inject([1, 2, 3]).limit(local, 2)
==>[1,2]  // collection returned

// Map behavior unchanged in both versions
gremlin> g.inject([a: 1, b: 2, c: 3]).limit(local, 1)
==>[a:1]  // Map entry returned (behavior unchanged)
----

If you need the old behavior of extracting single elements from collections, you can add `.unfold()` after the local step:

[source,text]
----
gremlin> g.inject([1, 2, 3]).limit(local, 1).unfold()
==>1
----

This change affects all three local collection manipulation steps when operating on iterable collections:
- `range(local, low, high)` 
- `limit(local, count)`
- `tail(local, count)`

See: link:https://issues.apache.org/jira/browse/TINKERPOP-2491[TINKERPOP-2491]

==== group() Value Traversal Semantics

The `group()` step takes two `by()` modulators. The first defines the key for the grouping, and the second acts upon the
values grouped to each key. The latter is referred to as the "value traversal". In earlier versions of TinkerPop,
using `order()` in the value traversal could produce an unexpected result if combined with a step like `fold()`.

[source,text]
----
gremlin> g.V().has("person","name",P.within("vadas","peter")).group().by().by(__.out().fold())
==>[v[2]:[],v[6]:[v[3]]]
gremlin> g.V().has("person","name",P.within("vadas","peter")).group().by().by(__.out().order().fold())
==>[v[6]:[v[3]]]
----

The example above shows that `v[2]` gets filtered away when `order()` is included. This was not expected behavior. The
problem can be more generally explained as an issue where a `Barrier` like `order()` can return an empty result. If this
step is followed by another `Barrier` that always produces an output like `sum()`, `count()` or `fold()` then the empty
result would not feed through to that following step. This issue has now been fixed and the two traversals from the
previous example now return the same results.

[source,text]
----
gremlin> g.V().has("person","name",P.within("vadas","peter")).group().by().by(__.out().fold())
==>[v[2]:[],v[6]:[v[3]]]
gremlin> g.V().has("person","name",P.within("vadas","peter")).group().by().by(__.out().order().fold())
==>[v[2]:[],v[6]:[v[3]]]
----

See: link:https://issues.apache.org/jira/browse/TINKERPOP-2971[TINKERPOP-2971]

==== By Modulation Semantics

*valueMap() and propertyMap() Semantics*

The `valueMap()` and `propertyMap()` steps have been changed to throw an error if multiple `by()` modulators are applied.
The previous behavior attempted to round-robin the `by()` but this wasn't possible for all providers.

**groupCount(), dedup(), sack(), sample(), aggregate() By Modulation Semantics**

The `groupCount()`, `dedup()`, `sack()`, `sample()`, and `aggregate()` steps has been changed to throw an error if
multiple `by()` modulators are applied. The previous behavior would ignore previous `by()` modulators and apply the
last one, which was not intuitive.

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3121[TINKERPOP-3121],
link:https://issues.apache.org/jira/browse/TINKERPOP-2974[TINKERPOP-2974]

==== Remove Undocumented `with()` modulation

There has long been a connection between the `with()` modulator, and mutating steps due to the design of
some of the interfaces in the gremlin traversal engine. This has led to several undocumented usages of the
`with()` modulator which have never been officially supported but have previously been functional.

As of 3.8.0 `with()` modulation of the following steps will no longer work: `addV()`, `addE()`, `property()`, `drop()`,
`mergeV()`, and `mergeE()`.

=== Upgrading for Providers

==== Graph System Providers

===== NoneStep Renaming

The `DiscardStep` is now renamed to `DiscardStep`. Providers who developed strategies or other optimizations around
`DiscardStep` should switch to `DiscardStep`. Note that `DiscardStep` has been repurposed as `none(P)` for filtering
collections as a complement to `any(P)` and `all(P)`.

===== Added `NotP`

Added a new subclass of `P` to model negated predicates. This has been introduced as the previous system of taking the
complementary PBiPredicate during negation does not account for edge cases involving illegal comparisons:

`!(1 < NaN) != (1 >= NaN)` -> `!(FALSE) != (FALSE)`

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3173[TINKERPOP-3173]

===== Set minimum Java version to 11

TinkerPop 3.8 requires a minimum of Java 11 for building and running. Support for Java 1.8 has been dropped.

===== Test Suite Changes

In 3.6.0, providers were encouraged to begin using the Gherkin test suite for testing Gremlin rather than the original
Java-based testing found in the `ProcessStandardSuite` and/or the `ProcessComputerSuite`. At that stage, the Gherkin
suite was still being developed to match the features of the earlier framework. As of 3.8.0, the Gherkin-based tests now
represent the primary way that Gremlin tests are developed, and the old system has fallen behind. The old suites have
been deprecated in favor of the Gherkin test suite, and providers should upgrade their implementations accordingly.
Going forward, the expectation is that the old Java-based suite will continue to exist, but will be focused on covering
test scenarios that cover either Java-specific syntax, lambdas, or other cases that only fall into Gremlin embedded use
cases. Graphs that need to support those cases would implement the `ProcessEmbeddedStandardSuite` and/or
`ProcessEmbeddedComputerSuite`.

Details on implementing the Gherkin tests can be found in the
link:https://tinkerpop.apache.org/docs/3.8.0/dev/provider/#gherkin-tests-suite[Provider Documentation].

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3136[TINKERPOP-3136]

===== New Gherkin Syntax for Side Effects

Added new syntax to the gherkin feature tests to directly add side effects to traversals.

[source,gherkin]
----
Given the modern graph
And using the side effect x defined as "v[marko].id"
----

Our complete Gherkin syntax for feature tests can be found in the link:https://tinkerpop.apache.org/docs/3.8.0/dev/developer/#_given[Developer Documentation].

===== Auto-promotion of Numbers

Previously, operations like `sum` or `sack` that involved mathematical calculations did not automatically promote the
result to a larger numeric type (e.g., from `int` to `long`) when needed. As a result, values could wrap around within
their current type, leading to unexpected behavior. This issue has now been resolved by enabling automatic type
promotion for results.

Now, any mathematical operations such as `Add`, `Sub`, `Mul`, and Div will now automatically promote to the next numeric type
if an overflow is detected. For integers, the promotion sequence is: byte → short → int → long → overflow exception. For
floating-point numbers, the sequence is: float → double → infinity.

As a example, in earlier versions, the following query:

[source,groovy]
----
g.withSack(32767s).inject(1s).sack(sum).sack()
----

would return a `short` overflow exception or wrap to `-1` depending on language, but now returns `32769i`.

See link:https://issues.apache.org/jira/browse/TINKERPOP-3115[TINKERPOP-3115]

===== choose() Semantics

The semantics for the `choose()` step where adjusted a bit for consistency and clarity. The current semantics can be
found in the link:https://tinkerpop.apache.org/docs/3.8.0/dev/provider/#choose-step[Provider Documentation]. In
addition the following points could be important for providers when upgrading.

*T.label Usage*

When using `T.label` with `choose()`, the implementation now uses a more efficient `TokenTraversal` instead of a
`LambdaMapTraversal`.

*Predicate Usage*

When using predicates (`P`) with `choose()`, the implementation now prefers the use of `is()` for more concrete
predicate handling rather than using a more abstract `PredicateTraverser`.

*ChooseSemantics enum*

The `ChooseStep` now provides a `ChooseSemantics` enum which helps indicate if the step is configured to work with
`IF_THEN` or `SWITCH` semantics which might be helpful in trying to optimize the step.

See: link:https://issues.apache.org/jira/browse/TINKERPOP-3178[TINKERPOP-3178]

===== Prefer OffsetDateTime

The default implementation for date type in Gremlin is now changed from the deprecated `java.util.Date` to the more
encompassing `java.time.OffsetDateTime`. This means the reference implementation for all date manipulation steps,
`asDate()`, `dateAdd()`, and `dateDiff()`, as well as helper methods `datetime()`, will return `OffsetDateTime`, whose
string representation will be in ISO 8601 format.

`Date` is still supported as incoming traverser results for these steps, as well as input into `dateDiff()` for
compatibility purposes. All dates are assumed to be in `UTC` (given epoch time).

This may impact providers who use TinkerGraph or whose implementation store dates as `java.util.Date`. While steps will
support `Date`, all date manipulations will output `OffsetDateTime`. If a user had persisted `Date` objects in the
database, upgrading to 3.8 may lead to the database having both types stored. It is recommended for users to perform
transformation of `Date` to `OffsetDateTime` to retain consistency.

===== PropertyMapStep Semantics

The semantics have changed for the handling of by modulators to the `valueMap` and `propertyMap` steps. Only one by
modulator is required to be accepted and an exception should be thrown when there are more than one `by()` modulators.
The exception thrown should contain the following: `valueMap()` and `propertyMap()` step can only have one by
modulator".

See: link:https://issues.apache.org/jira/browse/TINKERPOP-2974[TINKERPOP-2974]

===== Grammar Type Renaming

All the following types in the grammar have been renamed to follow consistent rules:

`genericLiteralArgument` -> `genericArgument`
`stringLiteralVarargsArgument` -> `stringNullableArgumentVarargs`
`genericLiteralMapArgument` -> `genericMapArgument`
`genericLiteralMapNullable` -> `genericMapNullableLiteral`
`genericLiteralMapNullableArgument` -> `genericMapNullableArgument`
`traversalStrategyList` -> `traversalStrategyVarargs`
`genericLiteralVarargs` -> `genericArgumentVarags`
`genericLiteralCollection` -> `genericCollectionLiteral`
`genericLiteralList` -> `genericLiteralVarargs`
`genericLiteralRange` -> `genericRangeLiteral`
`stringLiteralVarargs` -> `stringNullableLiteralVarargs`
`genericLiteralMap` -> `genericMapLiteral`

Additionally, `genericLiteralListArgument` and `stringLiteralList` have been removed in favor of `genericArgumentVarags`
and `stringNullableLiteralVarargs` respectively.

===== Removal of P.getOriginalValue()

`P.getOriginalValue()` has been removed as it was not offering much value and was often confused with `P.getValue()`.
Usage of `P.getOriginalValue()` often leads to unexpected results if called on a predicate which has had its value reset
after construction. All usages of `P.getOriginalValue()` should be replaced with `P.getValue()`.

===== Introduction of Step Interfaces

New interfaces step classes have been introduced to make it easier to supply alternative step class implementations.
Interfaces have been introduced for `AddEdgeStep`, `AddPropertyStep`, `AddVertexStep`, `CallStep`, `GraphStep`,
`IsStep`, `RangeGlobalStep`, `RangeLocalStep`, `TailGlobalStep`, `TailLocalStep`, and `VertexStep`.

===== GValue Step Parameterization

This release introduces `GValue` as a new representation of query parameters. GValue is designed to enable query caching
capabilities by persisting query parameters further in the traversal lifecycle. Parameters in a `gremlin-lang` script
are constructed into GValues and passed into `GraphTraversal`. The traversal is then populated with special
`GValueHolder` placeholder steps, which are temporary non-executable steps which implement a corresponding step
interface. TraversalStrategies are able to operate on these placeholder steps and update the traversal as normal. By
default, there is a new `OptimizationStrategy`, `GValueReductionStrategy` which cleans up the traversal by reducing all
`GValueHolder` steps with their corresponding concrete step object. Providers may choose disable this strategy in order
to store a fully constructed and optimized traversal with parameters into a query cache.

Some OptimizingStrategies will mutate the traversal based on the current value of a parameter. A simple example is
`CountStrategy` which will replace `outE("knows").count().is(0)` with `not(outE("knows"))`. This sort
of optimization presents a challenge for any provider who intends to swap the value of a parameter in the optimized
traversal. To resolve this issue, each `Traversal` is now bound to a `GValueManager`, whose purpose is to track if a
variable is "free" or "pinned". A "free" variable is one which can be substituted for any value without restriction. A
pinned variable is one which must remain bound to the current value. By parameterizing the above example,
`outE(GValue.of("edgeLabel", "knows")).count().is(GValue.of(count, 0))` will be optimized to
`not(outE(GValue.of("edgeLabel", "knows")))`. In this case, the `GValueManager` will report "edgeLabel" as a free
variable, as it can be substituted in the optimized traversal without any loss of meaning, however the variable "count"
will be pinned as the optimized traversal is not valid for other values of "count".

==== Graph Driver Providers

===== Prefer OffsetDateTime

The default implementation for date type in Gremlin is now changed from the deprecated `java.util.Date` to the more
encompassing `java.time.OffsetDateTime`. This means the reference implementation for all date manipulation steps,
`asDate()`, `dateAdd()`, and `dateDiff()`, as well as helper methods `datetime()`, will return `OffsetDateTime`, whose
string representation will be in ISO 8601 format.

This means that drivers should use the extended `OffsetDateTime` type in the IO specs to serialize and deserialize
native date objects.